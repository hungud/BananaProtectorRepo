using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;

namespace BananaBotProtector
{
    public enum MyProtocolType : byte
    {
        Icmp = 1,
        IP = 4,
        Tcp = 6,
        Udp = 17,
        Other = 144,
        Http = 145
    }
    public static class BigEndianBitConverter
    {
        public static UInt16 ToUInt16(byte[] data, int startindex)
        {
            byte[] newUInt16 = new byte[] { data[startindex + 1], data[startindex] };
            return BitConverter.ToUInt16(newUInt16, 0);
        }
        public static UInt32 ToUInt32(byte[] data, int startindex)
        {
            byte[] newUInt32 = new byte[] { data[startindex + 3], data[startindex + 2], data[startindex + 1], data[startindex] };
            return BitConverter.ToUInt16(newUInt32, 0);
        }
        public static string ToString(byte[] data)
        {
            return Encoding.ASCII.GetString(data);
        }
    }
    public class Packet
    {
        public virtual byte[] HeaderBytes
        {
            get
            {
                return data;
            }
        }
        public virtual byte[] ChildBytes
        {
            get
            {
                return null;
            }
        }
        public virtual string Description()
        {
            return "Unsupported protocol";
        }
        protected byte[] data;
        public Packet()
        {
            ChildPacket = null;
        }
        public Packet(byte[] Data)
        {
            ChildPacket = null;
        }

        public virtual MyProtocolType PacketType
        {
            get
            {
                return MyProtocolType.Other;
            }
        }

        public Packet ChildPacket { get; set; }

    }
    public sealed class IPv4Packet : Packet
    {
        public MyProtocolType protocolType
        {
            get
            {
                switch (data[9])
                {
                    case (byte)MyProtocolType.Icmp: return MyProtocolType.Icmp;
                    case (byte)MyProtocolType.Tcp:
                        return MyProtocolType.Tcp;
                    case (byte)MyProtocolType.Udp: return MyProtocolType.Udp;
                    default: return MyProtocolType.Other;
                }
            }
        }
        public override byte[] HeaderBytes
        {
            get
            {
                byte[] header = new byte[HeaderLengthInBytes];
                Array.Copy(data, header, HeaderLengthInBytes);
                return header;
            }
        }
        public override byte[] ChildBytes
        {
            get
            {
                byte[] childBytes;
                if (TotalLength == data.Length)
                {
                    childBytes = new byte[TotalLength - HeaderLengthInBytes];
                }
                else  // else this is a piece of packet generated by icmp, and need to send n
                {
                    childBytes = new byte[8];
                }
                Array.Copy(data, HeaderLengthInBytes, childBytes, 0, childBytes.Length);

                return childBytes;
            }
        }
        public override string Description()
        {
            return ChildPacket.Description();
        }
        public IPAddress SourceAddress
        {
            get
            {
                return new IPAddress(new byte[] { data[12], data[13], data[14], data[15] });
            }
        }
        public IPAddress DestAddress
        {
            get
            {
                return new IPAddress(new byte[] { data[16], data[17], data[18], data[19] });
            }
        }
        public byte IHL
        {
            get
            {
                return data[0];
            }
        }
        public byte DSCP
        {
            get
            {
                return data[1];
            }
        }
        public ushort TotalLength
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 2);
            }
        }
        public ushort ID
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 4);
            }
        }
        public BitArray Flags
        {
            get
            {
                byte temp = data[6];
                BitArray res = new BitArray(3);
                int i;
                for (i = 0; i < 3; ++i)
                {
                    res[i] = Convert.ToBoolean(temp & 128);
                    temp *= 2;
                }
                return res;
            }
        }
        public byte HeaderLength
        {
            get
            {
                byte temp = data[0];
                return (byte)(temp & 15);
            }
        }
        public byte HeaderLengthInBytes
        {
            get
            {
                return (byte)(HeaderLength * 4);
            }
        }
        public BitArray FragmentOffset
        {
            get
            {
                byte temp = data[6];
                temp = (byte)(temp << 3);
                BitArray Offset = new BitArray(13);
                for (int i = 0; i < 5; ++i)
                {
                    Offset[i] = Convert.ToBoolean(temp & 128);
                    temp *= 2;
                }
                temp = data[7];
                for (int i = 0; i < 8; ++i)
                {
                    Offset[i + 5] = Convert.ToBoolean(temp & 128);
                    temp *= 2;
                }
                return Offset;
            }
        }
        public byte TTL
        {
            get
            {
                return data[8];
            }
        }
        public ushort HeaderChecksum
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 10);
            }
        }
        public byte[] Options
        {
            get
            {
                if (HeaderLength > 5)  //5 min 15 - max
                {
                    byte[] options = new byte[(HeaderLength - 5) * 4];
                    Array.Copy(data, 24, options, 0, options.Length);
                    return options;
                }
                return null;
            }
        }
        public override MyProtocolType PacketType
        {
            get
            {
                return MyProtocolType.IP;
            }
        }
        public IPv4Packet(byte[] data)
        {
            this.data = data;
            switch (protocolType)
            {
                case MyProtocolType.Icmp: ChildPacket = new IcmpPacket(ChildBytes); break;
                case MyProtocolType.Tcp: ChildPacket = new TcpPacket(ChildBytes); break;
                case MyProtocolType.Udp: ChildPacket = new UdpPacket(ChildBytes); break;
                case MyProtocolType.Other: ChildPacket = new Packet(ChildBytes); break;
                case MyProtocolType.Http: ChildPacket = new TcpPacket(ChildBytes); break;
            }
            //PacketType = MyProtocolType.IP;
        }

    }
    public sealed class UdpPacket : Packet
    {
        public ushort SourcePort
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 0);
            }
        }
        public ushort DestPort
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 2);
            }
        }
        public ushort Length
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 4);
            }
        }
        public ushort Checksum
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 6);
            }
        }
        public override byte[] HeaderBytes
        {
            get
            {
                byte[] header = new byte[8];
                Array.Copy(data, header, 8);
                return header;
            }
        }
        public override byte[] ChildBytes
        {
            get
            {
                byte[] childbytes = new byte[Length - 8];
                Array.Copy(data, 8, childbytes, 0, childbytes.Length);
                return childbytes;
            }
        }
        public override string Description()
        {
            return "[" + SourcePort.ToString() + "] -> [" + DestPort.ToString() + "]";
        }
        public override MyProtocolType PacketType
        {
            get
            {
                return MyProtocolType.Udp;
            }
        }
        public UdpPacket(byte[] Data)
        {
            this.data = Data;
            ChildPacket = null;
            //PacketType = MyProtocolType.Udp;
        }

    }
    public sealed class IcmpPacket : Packet
    {
        public enum Type : byte
        {
            EchoReply = 0,   //code = 0
            DestinationUnreachable = 3, // 0-15
            RedirectMessage = 5, //0-3
            EchoRequest = 8,     // 0
            RouterAdvertisment = 9, //0
            RouterSolicitation = 10, //0
            TimeExceeded = 11, //0-1
            BadIpHeader = 12, //0-2
            TimeStamp = 13,
            TimeStampReply = 14,
            ErrorType = 255
        }
        public enum DestinationUnreachableCodes : byte
        {
            DestinationNetworkUnreachable,
            DestinationHostUnreachable,
            DestinationProtocolUnreachable,
            DestinationPortUnreachable,
            FragmentationRequired,
            SourceRouteFailed,
            DestinationNetworkUnknown,
            DestinationHostUnknown,
            SourceHostIsolated,
            NetworkAdministrativelyProhibited,
            HostAdministrativelyProhibited,
            NetworkUnreachableForToS,
            HostUnreachableForToS,
            CommunicationAdministrativelyProhibited,
            HostPrecedenceViolation,
            PrecedenceCutoffInEffect
        }
        public enum RedirectMessageCodes : byte
        {
            RedirectDatagramForTheNetwork,
            RedirectDatagramForTheHost,
            RedirectDatagramForTheToSAndNetwork,
            RedirectDatagramForTheToSAndHost
        }
        public enum TimeExceededCodes : byte
        {
            TTLExpiredInTransit,
            FragmentReassemblyTimeExceeded

        }
        public enum BadIpHeaderCodes : byte
        {
            PointerIndicatesTheError,
            MissingaRequiredOption,
            BadLength
        }

        public ushort SequenceNumber
        {
            get
            {
                if (type == Type.EchoReply || type == Type.EchoRequest || type == Type.TimeStamp || type == Type.TimeStampReply)
                {
                    return BigEndianBitConverter.ToUInt16(data, 6);   //handle ou of range 0 8 13 14 
                }
                else throw new Exception();
            }
        }
        public byte Code
        {
            get
            {
                return data[1];
            }
        }
        public ushort NextHopMTU
        {
            get
            {
                if (type == Type.DestinationUnreachable && Code == 4)
                {
                    return BigEndianBitConverter.ToUInt16(data, 6);   //type 3 only 
                }
                else throw new Exception();
            }
        }
        public IPAddress IpAddress //for redirect type
        {
            get
            {
                if (type == Type.RedirectMessage)
                {
                    return new IPAddress(new byte[] { data[4], data[5], data[6], data[7] }); // 5 
                }
                else throw new Exception();
            }
        }
        public ushort Identifier
        {
            get
            {
                if (type == Type.EchoReply || type == Type.EchoRequest || type == Type.TimeStamp || type == Type.TimeStampReply)
                {
                    return BigEndianBitConverter.ToUInt16(data, 4); //13 14  8 0
                }
                else throw new Exception();
            }
        }
        public byte AdvertismentCount  //9
        {
            get
            {
                if (type == Type.RouterAdvertisment)
                {
                    return data[4];
                }
                else throw new Exception();
            }
        }
        public byte AddressEntrySize  //9
        {
            get
            {
                if (type == Type.RouterAdvertisment)
                {
                    return data[5];
                }
                else throw new Exception();
            }
        }
        public ushort Lifetime
        {
            get
            {
                if (type == Type.RouterAdvertisment)
                {
                    return BigEndianBitConverter.ToUInt16(data, 6); //9
                }
                else throw new Exception();



            }
        }
        public byte Pointer //12
        {
            get
            {
                if (type == Type.BadIpHeader)
                {
                    return data[4];
                }
                else throw new Exception();
            }
        }
        public UInt32 OriginateTimestamp //13 14
        {
            get
            {
                if (type == Type.TimeStamp || type == Type.TimeStampReply)
                {
                    return BigEndianBitConverter.ToUInt32(data, 8);
                }
                else throw new Exception();
            }
        }
        public UInt32 ReceiveTimestamp //14 13
        {
            get
            {
                if (type == Type.TimeStamp || type == Type.TimeStampReply)
                {
                    return BigEndianBitConverter.ToUInt32(data, 12);
                }
                else throw new Exception();
            }

        }
        public UInt32 TransmitTimestamp //13 14
        {
            get
            {
                if (type == Type.TimeStamp || type == Type.TimeStampReply)
                {
                    return BigEndianBitConverter.ToUInt32(data, 16);
                }
                else throw new Exception();
            }
        }
        public Type type
        {
            get
            {
                switch (data[0])
                {
                    case (byte)Type.EchoReply: //checksum
                        return Type.EchoReply;

                    //code = 0
                    case (byte)Type.DestinationUnreachable:
                        return Type.DestinationUnreachable;


                    case (byte)Type.RedirectMessage:
                        return Type.RedirectMessage;


                    case (byte)Type.EchoRequest:
                        return Type.EchoRequest;


                    case (byte)Type.RouterAdvertisment:
                        return Type.RouterAdvertisment;


                    case (byte)Type.RouterSolicitation:
                        return Type.RouterSolicitation;


                    case (byte)Type.TimeExceeded:
                        return Type.TimeExceeded;


                    case (byte)Type.BadIpHeader:
                        return Type.BadIpHeader;


                    case (byte)Type.TimeStamp:
                        return Type.TimeStamp;
                    case (byte)Type.TimeStampReply:
                        return Type.TimeStampReply;
                    default:
                        return Type.ErrorType;

                }
            }
        }
        public ushort Checksum
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 2);
            }
        }

        public override byte[] HeaderBytes
        {
            get
            {
                if (type != Type.ErrorType)
                {
                    byte[] header;
                    if (type == Type.RouterSolicitation)
                    {
                        header = new byte[4];
                        Array.Copy(data, 0, header, 0, 4);

                    }
                    else
                    {
                        header = new byte[8];
                        Array.Copy(data, 0, header, 0, 8);
                    }
                    return header;
                }
                else throw new Exception();
            }
        }
        public override byte[] ChildBytes
        {
            get
            {
                if (type != Type.ErrorType)
                {
                    byte[] childbytes;
                    if (type == Type.RouterSolicitation)
                    {
                        childbytes = new byte[data.Length - 4];
                        Array.Copy(data, 4, childbytes, 0, data.Length - 4);
                    }
                    else
                    {
                        childbytes = new byte[data.Length - 8];
                        Array.Copy(data, 8, childbytes, 0, data.Length - 8);
                    }
                    return childbytes;
                }
                else throw new Exception();
            }
        }
        public override string Description()
        {
            string res = "Тип: " + Enum.GetName(typeof(Type), type);
            switch (data[0])
            {
                case (byte)Type.DestinationUnreachable:
                    res += " Код: " + Enum.GetName(typeof(DestinationUnreachableCodes), Code);
                    break;
                case (byte)Type.RedirectMessage:
                    res += " Код: " + Enum.GetName(typeof(RedirectMessageCodes), Code);
                    break;
                case (byte)Type.TimeExceeded:
                    res += " Код: " + Enum.GetName(typeof(TimeExceededCodes), Code);
                    break;
                case (byte)Type.BadIpHeader:
                    res += " Код: " + Enum.GetName(typeof(BadIpHeaderCodes), Code);
                    break;
            }
            return res;
        }
        public override MyProtocolType PacketType
        {
            get
            {
                return MyProtocolType.Icmp;
            }
        }
        public IcmpPacket(byte[] data)
        {
            //PacketType = MyProtocolType.Icmp;
            this.data = data;
            if (type == Type.DestinationUnreachable || type == Type.RedirectMessage || type == Type.TimeExceeded || type == Type.BadIpHeader)
            {
                ChildPacket = new IPv4Packet(ChildBytes);
            }
        }

    }
    public sealed class TcpPacket : Packet
    {
        public ushort SourcePort
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 0);
            }
        }
        public ushort DestPort
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 2);
            }
        }
        public UInt32 SequenceNumber
        {
            get
            {
                return BigEndianBitConverter.ToUInt32(data, 4);
            }
        }
        public UInt32 AcknowledgementNumber
        {
            get
            {
                return BigEndianBitConverter.ToUInt32(data, 8);
            }
        }
        public byte HeaderLength
        {
            get
            {
                byte len = data[12];
                return (byte)(len >> 4);
            }
        }
        public BitArray Flags
        {
            get
            {
                BitArray flags = new BitArray(8);
                byte temp = data[13];
                for (int i = 0; i < 8; ++i)
                {
                    flags[i] = Convert.ToBoolean(temp & 128);
                    temp *= 2;
                }
                return flags;
            }
        }
        public ushort WindowSize
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 14);
            }
        }
        public ushort CheckSum
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 16);
            }
        }
        public ushort UrgentPointer
        {
            get
            {
                return BigEndianBitConverter.ToUInt16(data, 18);
            }
        }
        public byte[] Options
        {
            get
            {
                if (HeaderLength > 5)
                {
                    byte[] options = new byte[(HeaderLength - 5) * 4];
                    Array.Copy(data, 20, options, 0, options.Length);
                    return options;
                }
                else throw new Exception();
            }
        }
        public override byte[] HeaderBytes
        {
            get
            {
                byte[] headerBytes = new byte[HeaderLength * 4];
                Array.Copy(data, headerBytes, HeaderLength * 4);
                return headerBytes;
            }
        }
        public override byte[] ChildBytes
        {
            get
            {
                byte[] childBytes = new byte[data.Length - HeaderBytes.Length];
                Array.Copy(data, HeaderBytes.Length - 1, childBytes, 0, data.Length - HeaderBytes.Length);
                return childBytes;
            }
        }
        public override string Description()
        {

            return "[" + SourcePort.ToString() + "] -> [" + DestPort.ToString() + "]" + " Seq: " + SequenceNumber.ToString() + " Ack: " + AcknowledgementNumber.ToString() + " WindowSize: " + WindowSize.ToString();

        }
        public override MyProtocolType PacketType
        {
            get
            {
                return MyProtocolType.Tcp;

            }
        }
        public bool HttpInside { get; private set; }
        public TcpPacket(byte[] data)
        {
            this.data = data;
            if (ChildBytes.Length > 0)
            {
                if (SourcePort == 80 || SourcePort == 443 || SourcePort == 8443 || DestPort == 80 || DestPort == 443 || DestPort == 8433)
                    HttpInside = true;
                else HttpInside = false;
            }
            //PacketType = MyProtocolType.Tcp;
            ChildPacket = null;
        }
    }

}
